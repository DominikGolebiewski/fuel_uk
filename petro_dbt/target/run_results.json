{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.8.0", "generated_at": "2024-06-21T21:00:37.352774Z", "invocation_id": "00c5cfc1-e684-49c0-906a-b29bb090025b", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2024-06-21T21:00:25.632002Z", "completed_at": "2024-06-21T21:00:25.657655Z"}, {"name": "execute", "started_at": "2024-06-21T21:00:25.658166Z", "completed_at": "2024-06-21T21:00:37.044276Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 11.43749213218689, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.petro.stg_petro", "compiled": true, "compiled_code": "import os\nimport pandas as pd\nimport json\nimport requests\nimport logging\nfrom datetime import datetime\nfrom slugify import slugify\n\n# Setting up the logging configuration to append to the log file\nlogging.basicConfig(level=logging.INFO, filename='fuel_price_fetcher.log', \n                    filemode='a', format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\nclass FuelPriceFetcher:\n\n    HEADERS = {\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36'\n    }\n\n    def __init__(self, retailer, url):\n        self.retailer = retailer\n        self.url = url\n        self.data = None\n        self.df = None\n        self.logger = logging.getLogger(f'FuelPriceFetcher_{retailer}')\n\n    def fetch_data(self):\n        try:\n            response = requests.get(self.url, headers=self.HEADERS)\n            response.raise_for_status()\n            self.data = response.json()\n            self.save_data_to_file()\n            self.logger.info(f'Successfully fetched data for {self.retailer}')\n        except requests.exceptions.RequestException as e:\n            self.logger.error(f'Error fetching data for {self.retailer}: {e}')\n            self.data = {}\n\n    def save_data_to_file(self):\n        try:\n            updated_at = self.data.get('last_updated', datetime.now().strftime('%Y-%m-%d_%H-%M-%S'))\n            if isinstance(updated_at, int):\n                updated_at = datetime.fromtimestamp(updated_at).strftime('%Y-%m-%d_%H-%M-%S')\n            else:\n                updated_at = datetime.strptime(updated_at, '%d/%m/%Y %H:%M:%S').strftime('%d_%m_%Y_%H_%M_%S')\n            \n            retailer_slug = slugify(self.retailer)\n            retailer_folder = os.path.join('files', retailer_slug)\n            os.makedirs(retailer_folder, exist_ok=True)\n            \n            filename = f'{retailer_slug}_{updated_at}.json'\n            file_path = os.path.join(retailer_folder, filename)\n            \n            with open(file_path, 'w') as json_file:\n                json.dump(self.data, json_file, indent=4)\n                \n            self.logger.info(f'Successfully saved data to {file_path}')\n        except Exception as e:\n            self.logger.error(f'Error saving data for {self.retailer}: {e}')\n\n    def process_data(self):\n        try:\n            if 'stations' in self.data:\n                self.df = pd.json_normalize(self.data['stations'], sep='_')\n                all_possible_prices = ['prices_B7', 'prices_E10', 'prices_E5', 'prices_SDV']\n                for price in all_possible_prices:\n                    if price not in self.df.columns:\n                        self.df[price] = None\n                self.df['last_updated'] = self.data.get('last_updated')\n                self.df['retailer'] = self.retailer\n                self.logger.info(f'Successfully processed data for {self.retailer}')\n            else:\n                self.df = pd.DataFrame()\n                self.logger.warning(f'No stations data found for {self.retailer}')\n        except Exception as e:\n            self.logger.error(f'Error processing data for {self.retailer}: {e}')\n            self.df = pd.DataFrame()\n\n    def get_dataframe(self):\n        self.fetch_data()\n        self.process_data()\n        return self.df\n\nclass FuelPricesAggregator:\n    def __init__(self, urls):\n        self.urls = urls\n        self.dataframes = []\n        self.logger = logging.getLogger('FuelPricesAggregator')\n\n    def aggregate_data(self):\n        for entry in self.urls:\n            retailer = entry['retailer']\n            self.logger.info(f'Processing data for {retailer}')\n            url = entry['url']\n            self.logger.info(f'Fetching data from {url}')\n            fetcher = FuelPriceFetcher(retailer, url)\n            df = fetcher.get_dataframe()\n            self.dataframes.append(df)\n        try:\n            combined_df = pd.concat(self.dataframes, ignore_index=True)\n            self.logger.info('Successfully aggregated data from all retailers')\n        except ValueError as e:\n            self.logger.error(f'Error aggregating data: {e}')\n            combined_df = pd.DataFrame()\n        return combined_df\n\ndef model(dbt, session):\n    dbt.config(materialized=\"table\")\n    urls = [\n        {'retailer': 'Applegreen UK', 'url': 'https://applegreenstores.com/fuel-prices/data.json'},\n        {'retailer': 'Ascona Group', 'url': 'https://fuelprices.asconagroup.co.uk/newfuel.json'},\n        {'retailer': 'ASDA', 'url': 'https://storelocator.asda.com/fuel_prices_data.json'},\n        {'retailer': 'BP', 'url': 'https://www.bp.com/en_gb/united-kingdom/home/fuelprices/fuel_prices_data.json'},\n        {'retailer': 'Esso', 'url': 'https://fuelprices.esso.co.uk/latestdata.json'},\n        {'retailer': 'JET Retail UK', 'url': 'https://jetlocal.co.uk/fuel_prices_data.json'},\n        {'retailer': 'Morrisons', 'url': 'https://www.morrisons.com/fuel-prices/fuel.json'},\n        {'retailer': 'Moto', 'url': 'https://moto-way.com/fuel-price/fuel_prices.json'},\n        {'retailer': 'Motor Fuel Group', 'url': 'https://fuel.motorfuelgroup.com/fuel_prices_data.json'},\n        {'retailer': 'Rontec', 'url': 'https://www.rontec-servicestations.co.uk/fuel-prices/data/fuel_prices_data.json'},\n        {'retailer': 'Sainsburys', 'url': 'https://api.sainsburys.co.uk/v1/exports/latest/fuel_prices_data.json'},\n        {'retailer': 'SGN', 'url': 'https://www.sgnretail.uk/files/data/SGN_daily_fuel_prices.json'},\n        {'retailer': 'Shell', 'url': 'https://www.shell.co.uk/fuel-prices-data.html'},\n        {'retailer': 'Tesco', 'url': 'https://www.tesco.com/fuel_prices/fuel_prices_data.json'},\n    ]\n    \n    aggregator = FuelPricesAggregator(urls)\n    combined_df = aggregator.aggregate_data()\n    return combined_df\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"petro\"\n    schema = \"main\"\n    identifier = \"stg_petro\"\n    \n    def __repr__(self):\n        return '\"petro\".\"main\".\"stg_petro\"'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "\"petro\".\"main\".\"stg_petro\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-06-21T21:00:37.074229Z", "completed_at": "2024-06-21T21:00:37.079212Z"}, {"name": "execute", "started_at": "2024-06-21T21:00:37.079692Z", "completed_at": "2024-06-21T21:00:37.239770Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.2637138366699219, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.petro.petro", "compiled": true, "compiled_code": "with petro_data as (\n\n        select \n            retailer,\n            brand,\n            address,\n            postcode,\n            location_latitude as latitude,\n            location_longitude as longitude,\n            \"prices_B7\" as b7,\n            \"prices_E10\" as e10,\n            \"prices_E5\" as e5,\n            \"prices_SDV\" as sdv,\n            last_updated,\n            -- row_number() over(partition by retailer, brand, strftime(DATE last_updated, '%d/%m/%Y'), address, postcode order by last_updated desc) as row_num,\n            md5(cast(coalesce(cast(retailer as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(brand as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(address as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(last_updated as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as surrogate_key\n        from \"petro\".\"main\".\"stg_petro\"\n\n        \n\n)\nselect *\nfrom petro_data", "relation_name": "\"petro\".\"main\".\"petro\""}], "elapsed_time": 12.284757375717163, "args": {"defer": false, "write_json": true, "quiet": false, "log_level": "info", "static_parser": true, "log_format": "default", "printer_width": 80, "partial_parse": true, "project_dir": "/home/runner/work/fuel_uk/fuel_uk/petro_dbt", "which": "run", "vars": {}, "require_resource_names_without_spaces": false, "send_anonymous_usage_stats": true, "log_format_file": "debug", "show_resource_report": false, "print": true, "populate_cache": true, "strict_mode": false, "log_level_file": "debug", "partial_parse_file_diff": true, "warn_error_options": {"include": [], "exclude": []}, "macro_debugging": false, "select": [], "version_check": true, "source_freshness_run_project_hooks": false, "log_path": "/home/runner/work/fuel_uk/fuel_uk/petro_dbt/logs", "indirect_selection": "eager", "enable_legacy_logger": false, "invocation_command": "dbt run", "profiles_dir": "/home/runner/work/fuel_uk/fuel_uk/petro_dbt", "exclude": [], "introspect": true, "use_colors_file": true, "require_explicit_package_overrides_for_builtin_materializations": true, "empty": false, "cache_selected_only": false, "favor_state": false, "use_colors": true, "log_file_max_bytes": 10485760}}